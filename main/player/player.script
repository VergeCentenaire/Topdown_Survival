shoot_cooldown = .2 --seconds
player_rotation = vmath.quat()
base_speed = 2
walk_speed = base_speed
sprint_speed = base_speed * 2.5

function init(self)
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	msg.post(".", "acquire_input_focus")

	--initialize the player rotation
	player_rotation = go.get_rotation()

	--initializing move properties
	self.speed = walk_speed
	self.is_moving = false

	--initializing player state
	self.fire = false
	self.last_shot = 0 --because no shot has been fired for now
end

function on_input(self, action_id, action)
	--get current game object's position
	local player_position = go.get_position()

	--enable sprinting when key is pressed, reset speed value to walk
	if action_id == hash("run") and action.pressed then
		self.speed = sprint_speed
	elseif action_id == hash("run") and action.released then
		self.speed = walk_speed
	end

	--move on x and y by adding speed value (sprint or not) to the player position
	if action_id == hash("right") then
		player_position.x = player_position.x + self.speed
		sprite.play_flipbook("/player#upper_body", "walk")
	elseif action_id == hash("left") then
		player_position.x = player_position.x - self.speed
	elseif action_id == hash("up") then
		player_position.y = player_position.y + self.speed
	elseif action_id == hash("down") then
		player_position.y = player_position.y - self.speed
	end

	--track the last cursor position on the screen
	if not action_id then
		local target_position = vmath.vector3(action.x, action.y, 0)
		print("player rotation", target_position)
		
		--calculate the player rotation
		player_rotation = math.atan2(target_position.y - go.get_position().y, target_position.x - go.get_position().x)
		go.set_rotation(vmath.quat_rotation_z(player_rotation))
	end

	--enable to shoot
	if action_id == hash("touch") and action.released then
		--tracks current time
		local now = socket.gettime()
		--get the world position of the child factory game object
		local muzzle_pos = go.get_world_position("/muzzle")
		local target_position = vmath.vector3(action.x, action.y, 0)
		local dir = vmath.normalize(target_position - muzzle_pos)

		--current time is now used as a value for last_shot and will be inferior to the next one
		if now > (self.last_shot + shoot_cooldown) then
			self.last_shot = now 
			print("Fire!")

			--trigger factory on bullet factory game object position
			factory.create("/bullet_factory#factory", muzzle_pos, nil, {
				direction = dir}, 0.6)
		else
				--if not firing then it's cooling down
				print("Cooldown")
		end
	end
	
	--set the new position of the current game object, the player
	go.set_position(player_position)
end

function update(self, dt)
	--get current player rotation of the player, each frame
	--player_rotation = go.get_world_rotation()
	--print(player_rotation)
end

function fixed_update(self, dt)

end

function final(self)
	msg.post(".", "release_input_focus")
end