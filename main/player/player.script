shoot_cooldown = .2 --seconds
player_rotation = vmath.quat()
base_speed = 2
walk_speed = base_speed
sprint_speed = base_speed * 2.5

function init(self)
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	msg.post(".", "acquire_input_focus")

	--initialize the player rotation
	player_rotation = go.get_rotation()

	--initializing move properties
	self.speed = walk_speed
	self.is_moving = false

	--initializing player state
	self.fire = false
	self.last_shot = 0 --because no shot has been fired for now
end

function on_input(self, action_id, action)
	--get current game object's position
	local player_position = go.get_position()

	--enable sprinting when key is pressed, reset speed value to walk
	if action_id == hash("run") and action.pressed then
		self.speed = sprint_speed
	elseif action_id == hash("run") and action.released then
		self.speed = walk_speed
	end

	--move on x and y by adding speed value (sprint or not) to the player position
	if action_id == hash("right") then
		player_position.x = player_position.x + self.speed
		sprite.play_flipbook("/player#upper_body", "walk")
	elseif action_id == hash("left") then
		player_position.x = player_position.x - self.speed
	elseif action_id == hash("up") then
		player_position.y = player_position.y + self.speed
	elseif action_id == hash("down") then
		player_position.y = player_position.y - self.speed
	end

	--enable to shoot
	if action_id == hash("touch") and action.released then

		--tracks current time
		local now = socket.gettime()
		--get the world position of the child factory game object
		local bullet_factory = go.get_world_position("/bullet_factory")
		

		if now > (self.last_shot + shoot_cooldown) then
			self.last_shot = now --current time is now used as a value for last_shot and will be inferior to the next one
			print("Fire!")

			--trigger factory on bullet factory game object position
			factory.create("/bullet_factory#factory", bullet_factory, player_rotation, nil, 1)
		else
			--if not firing then it's cooling down
			print("Cooldown")
		end
	end
	
	--set the new position of the current game object, the player
	go.set_position(player_position)
end

function update(self, dt)
	--get current player rotation of the player, each frame
	--player_rotation = go.get_world_rotation()
	--print(player_rotation)
end

function fixed_update(self, dt)

end

function final(self)
	msg.post(".", "release_input_focus")
end